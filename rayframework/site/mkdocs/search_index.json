{
    "docs": [
        {
            "location": "/", 
            "text": "Ray Framework\n\n\nRay is a framework that helps you to deliver well-designed software without been stuck in your framework. Ray it's a ready to production framework that contains a uWSGI server ready to be used on production environment.\n\n\nAre you using Google App Engine? Great! Ray is compatible with it.\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nEasy APIs\n\n\nDatabase Hooks\n\n\nAuthentication\n\n\nProtecting API\n\n\nuWSGI built-in server\n\n\nIntegration with SQLAlchemy\n\n\nIntegration with Google App Engine\n\n\n\n\nAuthor\n\n\nFelipe Volpone", 
            "title": "Home"
        }, 
        {
            "location": "/#ray-framework", 
            "text": "Ray is a framework that helps you to deliver well-designed software without been stuck in your framework. Ray it's a ready to production framework that contains a uWSGI server ready to be used on production environment.  Are you using Google App Engine? Great! Ray is compatible with it.", 
            "title": "Ray Framework"
        }, 
        {
            "location": "/#features", 
            "text": "Easy APIs  Database Hooks  Authentication  Protecting API  uWSGI built-in server  Integration with SQLAlchemy  Integration with Google App Engine", 
            "title": "Features"
        }, 
        {
            "location": "/#author", 
            "text": "Felipe Volpone", 
            "title": "Author"
        }, 
        {
            "location": "/documentation/", 
            "text": "Features\n\n\nEasy APIs\n\n\nCreate a model and then decorated it with the endpoint decorator.\n\n\nfrom ray.endpoint import endpoint\nfrom ray_sqlalchemy import AlchemyModel\nfrom sqlalchemy import Column, Integer, String\n\nBase = declarative_base()\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    name = StringProperty()\n    age = IntegerProperty()\n\n\n\n\nNow, you have the http methods to interact with your model using the urls:\n\n\n\n\n\n\n\n\nHTTP Verb\n\n\nPath\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGET\n\n\n/api/user\n\n\nList all users\n\n\n\n\n\n\nGET\n\n\n/api/user/{id}\n\n\nGet one user\n\n\n\n\n\n\nPOST\n\n\n/api/user\n\n\nCreate an user\n\n\n\n\n\n\nPUT\n\n\n/api/user/{id}\n\n\nUpdate an user\n\n\n\n\n\n\nDELETE\n\n\n/api/user/{id}\n\n\nDelete an user\n\n\n\n\n\n\n\n\nHooks\n\n\nHooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed \nbefore save the model, after the model be saved or before the model be deleted\n.\n\n\nfrom ray.hooks import Hook\n\nclass AgeValidationHook(Hook):\n    def before_save(self, user):\n        if user.age \n 18:\n            raise Exception('The user must have more than 18 years')\n        return True\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    hooks = [AgeValidationHook]\n    name = StringProperty()\n    age = IntegerProperty()\n\n\n\n\nAvailable Hooks:\n\n\n\n\nbefore_delete\n\n\nbefore_save\n\n\nafter_save\n\n\n\n\nThen, if you call the .put() method of UserModel and the user doesn't has age bigger than 18, an Exception will be raised.\n\n\nActions\n\n\nActions provide a simple way to you create behavior in your models through your api. After writing the code bellow, you can use the url \n/api/user/user_id/activate\n to invoke the activate_user method.\n\n\nfrom ray.actions import ActionAPI, action\n\nclass ActionUser(ActionAPI):\n    __model__ = UserModel\n\n    @action(\n/activate\n)\n    def activate_user(self, model_id):\n        user = storage.get(UserModel, model_id)\n        user.activate = True\n        storage.put(user)\n\n\n\n\nAuthentication\n\n\nRay has a built-in authentication module. To use it, you just need to inherit the Authentication class and implement the method \nauthenticate\n. In this method, you'll check the data in the database and then return if the user can login or not. Remember that this method must return a dictionary if the authentication succeeded.\n\n\nfrom ray.authentication import Authentication\n\n\nclass MyAuth(Authentication):\n\n    @classmethod\n    def authenticate(cls, username, password):\n        user = User.query(User.username == username, User.password == password).one()\n        return {'username': 'ray'} if user else None\n\n\n\n\nIf you want protect all the operations in this endpoint, you can just add this:\n\n\n@endpoint('/person', authentication=MyAuth)\nclass PersonModel(ModelInterface):\n    pass\n\n\n\n\nAfter protect your endpoint via an Authentication, you will need to be loged in to don't get a 403 status code. To do this:\n\n\nLogin\n\n\nimport request\nrequest.post('http://localhost:8080/api/_login',\n             data={\nusername\n: \nyourusername\n, \npassword\n: \nyourpassword\n})\n\n\n\n\nLogout\n\n\nimport request\nrequest.get('http://localhost:8080/api/_logout')\n\n\n\n\nShields\n\n\nRay has an option to you protect just some HTTP methods of your endpoint: using Shields. How it works? You inherit from the Shield class and implement just the http method that you \nwant to protect\n.\n\n\nclass PersonShield(Shield):\n    __model__ = PersonModel\n\n    def get(self, info):\n        return info['profile'] == 'admin'\n\n    # def put(self, info): pass\n\n    # def post(self, info): pass\n\n    # def delete(self, info): pass\n\n\n\n\nThis shield protects the GET method of /api/person. The parameter \ninfo\n in the get method on the shield, is the dictionary returned on your Authentication class. So, all Shields's methods receive this parameter. When you overwrite\na method, Ray will assume that method is under that Shield protection.\n\n\nShields with Actions\n\n\nIf you wanna to protect an action you can do this with Shield. To do this, you just need to implement a @classmethod method in your Shield, \nthat doesnt has one of these names: get, delete, post or put\n.\nIf this Action is not used by an authenticated user, the parameter info in your Shiled's method will be None.\n\n\n\nclass UserShield(Shield):\n    __model__ = UserModel\n\n    @classmethod\n    def protect_enable(cls, info):\n        return info['profile'] == 'admin'\n\n\nclass ActionUser(ActionAPI):\n    __model__ = UserModel\n\n    @action('/enable', protection=UserShield.protect_enable)\n    def enable_user(self, model_id):\n        user = session.get_user()\n        user.enabled = True\n        user.save()\n\n\n\n\nRunning server\n\n\nRay has a WSGI server to run your application. To use it, you just need to run the command bellow and start writing your business rules. The command parameter \n--wsgifile\n, must be used to tell to Ray in which file it should find your \napplication\n scope.\n\n\n# app.py file\nfrom ray.wsgi.wsgi import application\n\n\n\n\nray up --wsgifile=app.py", 
            "title": "Documentation"
        }, 
        {
            "location": "/documentation/#features", 
            "text": "", 
            "title": "Features"
        }, 
        {
            "location": "/documentation/#easy-apis", 
            "text": "Create a model and then decorated it with the endpoint decorator.  from ray.endpoint import endpoint\nfrom ray_sqlalchemy import AlchemyModel\nfrom sqlalchemy import Column, Integer, String\n\nBase = declarative_base()\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    name = StringProperty()\n    age = IntegerProperty()  Now, you have the http methods to interact with your model using the urls:     HTTP Verb  Path  Description      GET  /api/user  List all users    GET  /api/user/{id}  Get one user    POST  /api/user  Create an user    PUT  /api/user/{id}  Update an user    DELETE  /api/user/{id}  Delete an user", 
            "title": "Easy APIs"
        }, 
        {
            "location": "/documentation/#hooks", 
            "text": "Hooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed  before save the model, after the model be saved or before the model be deleted .  from ray.hooks import Hook\n\nclass AgeValidationHook(Hook):\n    def before_save(self, user):\n        if user.age   18:\n            raise Exception('The user must have more than 18 years')\n        return True\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    hooks = [AgeValidationHook]\n    name = StringProperty()\n    age = IntegerProperty()  Available Hooks:   before_delete  before_save  after_save   Then, if you call the .put() method of UserModel and the user doesn't has age bigger than 18, an Exception will be raised.", 
            "title": "Hooks"
        }, 
        {
            "location": "/documentation/#actions", 
            "text": "Actions provide a simple way to you create behavior in your models through your api. After writing the code bellow, you can use the url  /api/user/user_id/activate  to invoke the activate_user method.  from ray.actions import ActionAPI, action\n\nclass ActionUser(ActionAPI):\n    __model__ = UserModel\n\n    @action( /activate )\n    def activate_user(self, model_id):\n        user = storage.get(UserModel, model_id)\n        user.activate = True\n        storage.put(user)", 
            "title": "Actions"
        }, 
        {
            "location": "/documentation/#authentication", 
            "text": "Ray has a built-in authentication module. To use it, you just need to inherit the Authentication class and implement the method  authenticate . In this method, you'll check the data in the database and then return if the user can login or not. Remember that this method must return a dictionary if the authentication succeeded.  from ray.authentication import Authentication\n\n\nclass MyAuth(Authentication):\n\n    @classmethod\n    def authenticate(cls, username, password):\n        user = User.query(User.username == username, User.password == password).one()\n        return {'username': 'ray'} if user else None  If you want protect all the operations in this endpoint, you can just add this:  @endpoint('/person', authentication=MyAuth)\nclass PersonModel(ModelInterface):\n    pass  After protect your endpoint via an Authentication, you will need to be loged in to don't get a 403 status code. To do this:", 
            "title": "Authentication"
        }, 
        {
            "location": "/documentation/#login", 
            "text": "import request\nrequest.post('http://localhost:8080/api/_login',\n             data={ username :  yourusername ,  password :  yourpassword })", 
            "title": "Login"
        }, 
        {
            "location": "/documentation/#logout", 
            "text": "import request\nrequest.get('http://localhost:8080/api/_logout')", 
            "title": "Logout"
        }, 
        {
            "location": "/documentation/#shields", 
            "text": "Ray has an option to you protect just some HTTP methods of your endpoint: using Shields. How it works? You inherit from the Shield class and implement just the http method that you  want to protect .  class PersonShield(Shield):\n    __model__ = PersonModel\n\n    def get(self, info):\n        return info['profile'] == 'admin'\n\n    # def put(self, info): pass\n\n    # def post(self, info): pass\n\n    # def delete(self, info): pass  This shield protects the GET method of /api/person. The parameter  info  in the get method on the shield, is the dictionary returned on your Authentication class. So, all Shields's methods receive this parameter. When you overwrite\na method, Ray will assume that method is under that Shield protection.", 
            "title": "Shields"
        }, 
        {
            "location": "/documentation/#shields-with-actions", 
            "text": "If you wanna to protect an action you can do this with Shield. To do this, you just need to implement a @classmethod method in your Shield,  that doesnt has one of these names: get, delete, post or put .\nIf this Action is not used by an authenticated user, the parameter info in your Shiled's method will be None.  \nclass UserShield(Shield):\n    __model__ = UserModel\n\n    @classmethod\n    def protect_enable(cls, info):\n        return info['profile'] == 'admin'\n\n\nclass ActionUser(ActionAPI):\n    __model__ = UserModel\n\n    @action('/enable', protection=UserShield.protect_enable)\n    def enable_user(self, model_id):\n        user = session.get_user()\n        user.enabled = True\n        user.save()", 
            "title": "Shields with Actions"
        }, 
        {
            "location": "/documentation/#running-server", 
            "text": "Ray has a WSGI server to run your application. To use it, you just need to run the command bellow and start writing your business rules. The command parameter  --wsgifile , must be used to tell to Ray in which file it should find your  application  scope.  # app.py file\nfrom ray.wsgi.wsgi import application  ray up --wsgifile=app.py", 
            "title": "Running server"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nDo you want to see Ray in action? Check the \nexamples\n directory.\n\n\nIf you wanna use Peewee (or SQLAlchemey), check this \nhere\n\n\nIf you wanne use Google App Engine \nhere", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "Do you want to see Ray in action? Check the  examples  directory.  If you wanna use Peewee (or SQLAlchemey), check this  here  If you wanne use Google App Engine  here", 
            "title": "Examples"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Getting Started\n\n\nBuilding our first application with Ray\n\n\nLets see how easy is build a blog (again? really? \u00af\\\n(\u30c4)\n/\u00af) using \nRay\n!\n\n\nTo do this, we will use the Peewee ORM, which Ray is absolutely compatible (as well with SQLAlchemy and Google App Engine).\n\n\nSo, lets install Peewee and Ray and the Ray plugin to integrated with the ORM.\n\n\npip install peewee\npip install ray_framework\npip install ray_peewee\n\n\n\n\nAfter that, create an \napp.py\n file with our first model: Post.\n\n\n# app.py\n\nimport peewee\nfrom ray_peewee.all import PeeweeModel\nfrom ray.wsgi.wsgi import application\nfrom ray.endpoint import endpoint\n\n\ndatabase = peewee.SqliteDatabase('example.db')\n\n\nclass DBModel(PeeweeModel):\n    class Meta:\n        database = database\n\n\n@endpoint('/user')\nclass Post(DBModel):\n    title = peewee.CharField()\n    description = peewee.TextField()\n\n\n\n\n\nNow, lets run our application and check if it's everything alright.\n\nIf don't want to use curl, you can use the Postman app. You just need import \nthis file\n.\n\n\nray up --wsgifile=app.py\n# if you're using virtualenv\nray up --wsgifile=app.py --env \nenv_dir\n\n\n\n\n\nNow, \nwe can interact with our blog!\n\n\nCreating a post\n\n\ncurl -X POST -H \nContent-Type: application/json\n -d '{\n    \ntitle\n: \nNew blog!\n,\n    \ndescription\n: \nlets do this\n\n}' \nhttp://localhost:8080/api/post\n\n\n\n\n\nListing all posts\n\n\ncurl -X GET \nhttp://localhost:8080/api/post/\n\n\n\n\n\nGet one post\n\n\ncurl -X GET \nhttp://localhost:8080/api/post/1\n\n\n\n\n\nUpdating a post\n\n\ncurl -X PUT -H \nContent-Type: application/json\n -d '{\ntitle\n: \nlets change the title.\n}' \nhttp://localhost:8080/api/post/1\n\n\n\n\n\nDelete a post\n\n\ncurl -X DELETE \nhttp://localhost:8080/api/post/1\n\n\n\n\n\nUsing Hooks\n\n\nHooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed:\n\n\n\n\nbefore save the model\n\n\nafter the model be saved\n\n\nbefore the model be deleted\n\n\n\n\nNow, let's use add a \nHook\n, to prevent that a post can be created without a title.\n\n\nclass PostHook(Hook):\n\n    def before_save(self, post):\n        if not post.title:\n            raise Exception('Title cannot be None')\n\n        return True\n\n\n\n\nTo connect this hook with the Post endpoint, you updat your Post class\n\n\n@endpoint('/user')\nclass Post(DBModel):\n    hooks = [PostHook]  # add this line\n\n    title = peewee.CharField()\n    description = peewee.TextField()\n\n\n\n\n\nUsing Actions\n\n\nActions provide a simple way to you create behavior in your models through your API. Actions can require that a parameter must be used in the url, like id, or don't require any parameter at all.\n\n\nfrom ray.actions import ActionAPI, action\n\nclass ActionPost(ActionAPI):\n    __model__ = Post\n\n    @action(\n/\nid\n/upper\n)\n    def upper_case(self, model_id):\n        post = Post.get(id=model_id)\n        post.update({'title': post.title.upper(), 'id': model_id})\n\n    @action(\n/now\n)\n    def now_action(self, model_id):\n        return datetime.now().strftime('%d/%m/%y')", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting_started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#building-our-first-application-with-ray", 
            "text": "Lets see how easy is build a blog (again? really? \u00af\\ (\u30c4) /\u00af) using  Ray !  To do this, we will use the Peewee ORM, which Ray is absolutely compatible (as well with SQLAlchemy and Google App Engine).  So, lets install Peewee and Ray and the Ray plugin to integrated with the ORM.  pip install peewee\npip install ray_framework\npip install ray_peewee  After that, create an  app.py  file with our first model: Post.  # app.py\n\nimport peewee\nfrom ray_peewee.all import PeeweeModel\nfrom ray.wsgi.wsgi import application\nfrom ray.endpoint import endpoint\n\n\ndatabase = peewee.SqliteDatabase('example.db')\n\n\nclass DBModel(PeeweeModel):\n    class Meta:\n        database = database\n\n\n@endpoint('/user')\nclass Post(DBModel):\n    title = peewee.CharField()\n    description = peewee.TextField()  Now, lets run our application and check if it's everything alright. If don't want to use curl, you can use the Postman app. You just need import  this file .  ray up --wsgifile=app.py\n# if you're using virtualenv\nray up --wsgifile=app.py --env  env_dir   Now,  we can interact with our blog!  Creating a post  curl -X POST -H  Content-Type: application/json  -d '{\n     title :  New blog! ,\n     description :  lets do this \n}'  http://localhost:8080/api/post   Listing all posts  curl -X GET  http://localhost:8080/api/post/   Get one post  curl -X GET  http://localhost:8080/api/post/1   Updating a post  curl -X PUT -H  Content-Type: application/json  -d '{ title :  lets change the title. }'  http://localhost:8080/api/post/1   Delete a post  curl -X DELETE  http://localhost:8080/api/post/1", 
            "title": "Building our first application with Ray"
        }, 
        {
            "location": "/getting_started/#using-hooks", 
            "text": "Hooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed:   before save the model  after the model be saved  before the model be deleted   Now, let's use add a  Hook , to prevent that a post can be created without a title.  class PostHook(Hook):\n\n    def before_save(self, post):\n        if not post.title:\n            raise Exception('Title cannot be None')\n\n        return True  To connect this hook with the Post endpoint, you updat your Post class  @endpoint('/user')\nclass Post(DBModel):\n    hooks = [PostHook]  # add this line\n\n    title = peewee.CharField()\n    description = peewee.TextField()", 
            "title": "Using Hooks"
        }, 
        {
            "location": "/getting_started/#using-actions", 
            "text": "Actions provide a simple way to you create behavior in your models through your API. Actions can require that a parameter must be used in the url, like id, or don't require any parameter at all.  from ray.actions import ActionAPI, action\n\nclass ActionPost(ActionAPI):\n    __model__ = Post\n\n    @action( / id /upper )\n    def upper_case(self, model_id):\n        post = Post.get(id=model_id)\n        post.update({'title': post.title.upper(), 'id': model_id})\n\n    @action( /now )\n    def now_action(self, model_id):\n        return datetime.now().strftime('%d/%m/%y')", 
            "title": "Using Actions"
        }
    ]
}