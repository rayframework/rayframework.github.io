{
    "docs": [
        {
            "location": "/", 
            "text": "Ray Framework\n\n\nRay on github\n\n\nRay is a framework that helps you to deliver well-designed software without been stuck in your framework.\n\n\nAre you using Google App Engine? Great! Ray is compatible with it.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nEasy APIs\n\n\nDatabase Hooks\n\n\nAuthentication\n\n\nProtecting API\n\n\nIntegration with Peewee and SQLAlchemy\n\n\nIntegration with Google App Engine\n\n\n\n\nDo you wanna know how to use Ray?\n\n\nYou can start with the \ndocumentation\n, the \ngetting started guide\n or checking a \nexample of a simple Evernote-like application\n.\n\n\nWhy use Ray?\n\n\nThe Ray framework it's a kind of mix of Django and Flask. Django it's the kind of framework that you're stuck with it (this is not always a problem), once you start using it, will become hard to get out of it. In the other side, Flask is a micro-framework that you can connect with a lot of plugins from the python community. Ray tries to get the best of both sides, having a small, but powerful core, and allowing plugins to connect with it.\n\n\nWith Ray you can develop powerful REST APIs in a simple way and have the core of your application not coupled with the framework.\n\n\nAuthors\n\n\nFelipe Volpone\n\n\nYou!", 
            "title": "Home"
        }, 
        {
            "location": "/#ray-framework", 
            "text": "", 
            "title": "Ray Framework"
        }, 
        {
            "location": "/#ray-on-github", 
            "text": "Ray is a framework that helps you to deliver well-designed software without been stuck in your framework.  Are you using Google App Engine? Great! Ray is compatible with it.", 
            "title": "Ray on github"
        }, 
        {
            "location": "/#features", 
            "text": "Easy APIs  Database Hooks  Authentication  Protecting API  Integration with Peewee and SQLAlchemy  Integration with Google App Engine", 
            "title": "Features"
        }, 
        {
            "location": "/#do-you-wanna-know-how-to-use-ray", 
            "text": "You can start with the  documentation , the  getting started guide  or checking a  example of a simple Evernote-like application .", 
            "title": "Do you wanna know how to use Ray?"
        }, 
        {
            "location": "/#why-use-ray", 
            "text": "The Ray framework it's a kind of mix of Django and Flask. Django it's the kind of framework that you're stuck with it (this is not always a problem), once you start using it, will become hard to get out of it. In the other side, Flask is a micro-framework that you can connect with a lot of plugins from the python community. Ray tries to get the best of both sides, having a small, but powerful core, and allowing plugins to connect with it.  With Ray you can develop powerful REST APIs in a simple way and have the core of your application not coupled with the framework.", 
            "title": "Why use Ray?"
        }, 
        {
            "location": "/#authors", 
            "text": "", 
            "title": "Authors"
        }, 
        {
            "location": "/#felipe-volpone", 
            "text": "", 
            "title": "Felipe Volpone"
        }, 
        {
            "location": "/#you", 
            "text": "", 
            "title": "You!"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Getting Started\n\n\nBuilding our first application with Ray\n\n\nLet's see how easy is build an Evernote-like app using \nRay\n!\n\n\nTo do this, we will use the Peewee ORM, which Ray is absolutely compatible (as well with SQLAlchemy and Google App Engine).\n\n\nInstall Peewee and Ray and the Ray plugin to integrated with the ORM.\n\n\nTL;DR: You can check the \nentire code here\n\n\nPS: This code is just to provide \nan example\n of how to use Ray.\n\n\npip install peewee\npip install ray_framework\npip install ray_peewee\n\n\n\n\nAfter that, create an \napp.py\n file with our models: Notebook and Note.\n\n\n# app.py\n\nimport peewee\nfrom ray_peewee.all import PeeweeModel\nfrom ray.wsgi.wsgi import application\nfrom ray.endpoint import endpoint\n\n\ndatabase = peewee.SqliteDatabase('example.db')\n\n\nclass DBModel(PeeweeModel):\n    class Meta:\n        database = database\n\n\n@endpoint('/notebook')\nclass Notebook(DBModel):\n    title = peewee.CharField()\n    update_at = peewee.BigIntegerField()\n    active = peewee.BooleanField(default=True)\n\n\n@endpoint('/note')\nclass Note(DBModel):\n    title = peewee.CharField()\n    update_at = peewee.BigIntegerField()\n    content = peewee.TextField()\n    notebook = peewee.ForeignKeyField(Notebook)\n\n\nif __name__ == '__main__':\n    database.connect()\n    database.create_tables([Notebook, Note], safe=True)\n    database.close()\n    application.run(debug=True, reloader=True)\n\n\n\n\n\nRun the application.\n\n\npython app.py\n\n\n\n\nNow, \nwe can interact with our app!\n\n\n\n\nCreating a notebook\n\n\n\n\ncurl -X POST -H \nContent-Type: application/json\n '{\ntitle\n: \nnew ideas\n} ' \nhttp://localhost:8080/api/notebook\n\n\n\n\n\n\n\nCreating a note\n\n\n\n\ncurl -X POST -H \nContent-Type: application/json\n '{\ntitle\n: \nnew ideas\n, \nnotebook\n: \n1\n} ' \nhttp://localhost:8080/api/note\n\n\n\n\n\n\n\nListing all notebooks\n\n\n\n\ncurl -X GET \nhttp://localhost:8080/api/notebook/\n\n\n\n\n\n\n\nSearching for a record\n\n\n\n\ncurl -X GET \nhttp://localhost:8080/api/notebook?title=new ideias\n\n\n\n\n\n\n\nGet one notebook\n\n\n\n\ncurl -X GET \nhttp://localhost:8080/api/notebook/1\n\n\n\n\n\n\n\nUpdating a notebook\n\n\n\n\ncurl -X PUT -H \nContent-Type: application/json\n -d '{\ntitle\n: \nlets change the title.\n}' \nhttp://localhost:8080/api/notebook/1\n\n\n\n\n\n\n\nDelete a notebook\n\n\n\n\ncurl -X DELETE \nhttp://localhost:8080/api/notebook/1\n\n\n\n\n\nUsing Hooks\n\n\nHooks are useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed:\n\n\n\n\nbefore save the model (the \nbefore_save\n method)\n\n\nafter the model be saved (the \nafter_save\n method)\n\n\nbefore the model be deleted (the \nbefore_delete\n method)\n\n\n\n\nNow, let's use add a \nDatabase Hook\n, to add some validations.\n\n\nfrom ray.hooks import DatabaseHook\n\nclass CreatedAtBaseHook(DatabaseHook):\n\n    def before_save(self, model):\n        model.update_at = int(datetime.now().strftime('%s')) * 1000\n        return True\n\n\nclass NoteHook(CreatedAtBaseHook):\n\n    def before_save(self, note):\n        super(NoteHook, self).before_save(note)\n\n        if not note.title:\n            raise Exception('Title cannot be None')\n\n        if not note.notebook_id:\n            raise Exception('A note only exists inside a notebook')\n\n        return True\n\n\nclass NotebookHook(CreatedAtBaseHook):\n\n    def before_save(self, notebook):\n        super(NotebookHook, self).before_save(notebook)\n\n        if not notebook.title:\n            raise Exception('Title cannot be None')\n\n        #notebook.owner = dict_to_model(User, SimpleNoteAuthentication.get_logged_user())\n        return True\n\n\n\n\nTo connect this hook with the Notebook endpoint, you just need add one line in your model\n\n\n@endpoint('/notebook')\nclass Notebook(DBModel):\n    hooks = [NotebookHook]\n\n@endpoint('/note')\nclass Note(DBModel):\n    hooks = [NoteHook]\n\n\n\n\nUsing Authentication\n\n\nRay has a built-in module of Authentication. You \ncan get more details of it here\n. Basically, we just need to override the authenticate method. \n\n\nfrom ray.authentication import Authentication, register\n\n@register\nclass SimpleNoteAuthentication(Authentication):\n\n    expiration_time = 5  # in minutes\n\n    @classmethod\n    def authenticate(cls, login_data):\n        users = User.select().where(User.username == login_data['username'],\n                                    User.password == login_data['password'])\n        if not any(users):\n            raise Exception('Wrong username or/and password')\n\n        return users[0].to_json()\n\n    @classmethod\n    def salt_key(cls):\n        return 'anything'\n\n\n\n\nAlso, let's create a User model and add the owner field in the Notebook model.\n\n\nclass UserHook(DatabaseHook):\n\n    def before_save(self, user):\n        users_same_username = (User.select()\n                                   .where(User.username == user.username))\n        if any(users_same_username):\n            raise Exception('The username is unique')\n\n        return True\n\n\nclass User(DBModel):\n    hooks = [UserHook]\n\n    username = peewee.CharField()\n    password = peewee.CharField()\n    profile = peewee.CharField()\n\n\nclass Profile(object):\n    ADMIN = 'admin'\n    DEFAULT = 'default'\n\n\n\n\nIn the notebook endpoint, we'll use the authentication argument to say that this endpoint it's under the authentication module. This means that you only can call the notebook endpoints when the user is logged in.\n\n\n@endpoint('/notebook', authentication=SimpleNoteAuthentication)\nclass Notebook(DBModel):\n    hooks = [NotebookHook]\n    owner = peewee.ForeignKeyField(User)\n\n@endpoint('/note', authentication=SimpleNoteAuthentication)\nclass Note(DBModel):\n    hooks = [NoteHook]\n\n\n\n\nIn the end of your app.py file, add these lines, to create some mock users:\n\n\nif __name__ == '__main__':\n    database.connect()\n    database.create_tables([User, Notebook, Note], safe=True)\n    User.create(username='admin', password='admin', profile=Profile.ADMIN)\n    User.create(username='john', password='123', profile=Profile.DEFAULT)\n    database.close()\n    application.run(debug=True, reloader=True)\n\n\n\n\n\nNow, you need to login in the application to get acess to the Post endpoint.\n\n\ncurl -X PUT -H \nContent-Type: application/json\n -d '{\n    \nusername\n: \nray\n,\n    \npassword\n: \nframework\n\n}' \nhttp://localhost:8080/api/_login\n\n\n\n\n\nUsing Actions\n\n\nActions help you to extend your endpoints and add more behavior to your application. So, we'll create to actions to invite someone to our notebook and to deactivate a notebook.\n\n\n\nclass MailHelper(object):\n\n    @classmethod\n    def send_email(self, to, message):\n        # fake send email\n        print('sending email to: %s with message: %s' % (to, message)) \n\n\nclass NotebookActions(Action):\n    __model__ = Notebook\n\n    @action('/\nid\n/invite', authentication=True)\n    def invite_to_notebook(self, notebook_id, parameters):\n        to = parameters['user_to_invite']\n        title = Notebook.select().where(Notebook.id == notebook_id)[0].title\n        message = 'Help me build new stuff in this notebook: %s' % (title)\n        MailHelper.send_email(to, message)\n\n    @action('/\nid\n/deactivate', protection=NotebookShield.only_owner_can_deactivate, authentication=True)\n    def deactivate(self, notebook_id, parameters):\n        notebook = Notebook.select().where(Notebook.id == int(notebook_id))[0]\n        notebook.active = False\n        notebook.update()\n\n\n\n\nCheck that the \ndeactivate\n method has the protection parameter pointing to a Shield. This is helpful when you wanna protect an Action. So, lets add the \nonly_owner_can_deactivate\n method in our shield.\n\n\nclass NotebookShield(Shield):\n    __model__ = Notebook\n\n    def delete(self, user_data, notebook_id, parameters):\n        return user_data['profile'] == Profile.ADMIN\n\n    @staticmethod\n    def only_owner_can_deactivate(user_data, notebook_id, parameters):\n        notebook = Notebook.select().where(Notebook.id == int(notebook_id))[0]\n        notebook_json = model_to_dict(notebook, recurse=False)\n        return user_data['id'] == notebook_json['owner']\n\n\n\n\n\nUsing Shields\n\n\nWith Shields, you can protect your endpoints. Let's imagine that only users with the admin profile can call the HTTP DELETE method of our notebook endpoint. To do that:\n\n\nclass NotebookShield(Shield):\n    __model__ = Notebook\n\n    def delete(self, user_data, notebook_id, parameters):\n        return user_data['profile'] == Profile.ADMIN\n\n\n\n\nDone!\n\n\nNow, you already know the main features of Ray, from these features you can develop anything that you want!\n\n\nThe Entire code\n\n\n\nfrom playhouse.shortcuts import dict_to_model, model_to_dict  # peewee\nimport peewee\n\nfrom datetime import datetime\n\nfrom ray.authentication import Authentication, register\nfrom ray.hooks import DatabaseHook\nfrom ray.wsgi.wsgi import application\nfrom ray.endpoint import endpoint\nfrom ray_peewee.all import PeeweeModel\nfrom ray.actions import Action, action\nfrom ray.shield import Shield\n\n\ndatabase = peewee.SqliteDatabase('example.db')\n\n\nclass DBModel(PeeweeModel):\n    class Meta:\n        database = database\n\n\nclass MailHelper(object):\n\n    @classmethod\n    def send_email(self, to, message):\n        # fake send email\n        print('sending email to: %s with message: %s' % (to, message))\n\n\nclass UserHook(DatabaseHook):\n\n    def before_save(self, user):\n        users_same_username = (User.select()\n                                   .where(User.username == user.username))\n        if any(users_same_username):\n            raise Exception('The username is unique')\n\n        return True\n\n\nclass User(DBModel):\n    hooks = [UserHook]\n\n    username = peewee.CharField()\n    password = peewee.CharField()\n    profile = peewee.CharField()\n\n\n@register\nclass SimpleNoteAuthentication(Authentication):\n\n    expiration_time = 5  # in minutes\n\n    @classmethod\n    def authenticate(cls, login_data):\n        users = User.select().where(User.username == login_data['username'],\n                                    User.password == login_data['password'])\n        if not any(users):\n            raise Exception('Wrong username or/and password')\n\n        return users[0].to_json()\n\n    @classmethod\n    def salt_key(cls):\n        return 'anything'  # do it rightly here\n\n\nclass CreatedAtBaseHook(DatabaseHook):\n\n    def before_save(self, model):\n        model.update_at = int(datetime.now().strftime('%s')) * 1000\n        return True\n\n\nclass NoteHook(CreatedAtBaseHook):\n\n    def before_save(self, note):\n        super(NoteHook, self).before_save(note)\n\n        if not note.title:\n            raise Exception('Title cannot be None')\n\n        if not note.notebook_id:\n            raise Exception('A note only exists inside a notebook')\n\n        return True\n\n\nclass NotebookHook(CreatedAtBaseHook):\n\n    def before_save(self, notebook):\n        super(NotebookHook, self).before_save(notebook)\n\n        if not notebook.title:\n            raise Exception('Title cannot be None')\n\n        notebook.owner = dict_to_model(User, SimpleNoteAuthentication.get_logged_user())\n        return True\n\n\n@endpoint('/notebook', authentication=SimpleNoteAuthentication)\nclass Notebook(DBModel):\n    hooks = [NotebookHook]\n\n    title = peewee.CharField()\n    update_at = peewee.BigIntegerField()\n    owner = peewee.ForeignKeyField(User)\n    active = peewee.BooleanField(default=True)\n\n\n@endpoint('/note', authentication=SimpleNoteAuthentication)\nclass Note(DBModel):\n    hooks = [NoteHook]\n\n    title = peewee.CharField()\n    update_at = peewee.BigIntegerField()\n    content = peewee.TextField()\n    notebook = peewee.ForeignKeyField(Notebook)\n\n\nclass NotebookShield(Shield):\n    __model__ = Notebook\n\n    def delete(self, user_data, notebook_id, parameters):\n        return user_data['profile'] == Profile.ADMIN\n\n    @staticmethod\n    def only_owner_can_deactivate(user_data, notebook_id, parameters):\n        notebook = Notebook.select().where(Notebook.id == int(notebook_id))[0]\n        notebook_json = model_to_dict(notebook, recurse=False)\n        return user_data['id'] == notebook_json['owner']\n\n\nclass NotebookActions(Action):\n    __model__ = Notebook\n\n    @action('/\nid\n/invite', authentication=True)\n    def invite_to_notebook(self, notebook_id, parameters):\n        to = parameters['user_to_invite']\n        title = Notebook.select().where(Notebook.id == notebook_id)[0].title\n        message = 'Help me build new stuff in this notebook: %s' % (title)\n        MailHelper.send_email(to, message)\n\n    @action('/\nid\n/deactivate', protection=NotebookShield.only_owner_can_deactivate, authentication=True)\n    def deactivate(self, notebook_id, parameters):\n        notebook = Notebook.select().where(Notebook.id == int(notebook_id))[0]\n        notebook.active = False\n        notebook.update()\n\n\nclass Profile(object):\n    ADMIN = 'admin'\n    DEFAULT = 'default'\n\n\nif __name__ == '__main__':\n    database.connect()\n    database.create_tables([User, Notebook, Note], safe=True)\n    User.create(username='admin', password='admin', profile=Profile.ADMIN)\n    User.create(username='john', password='123', profile=Profile.DEFAULT)\n    database.close()\n    application.run(debug=True, reloader=True)", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#building-our-first-application-with-ray", 
            "text": "Let's see how easy is build an Evernote-like app using  Ray !  To do this, we will use the Peewee ORM, which Ray is absolutely compatible (as well with SQLAlchemy and Google App Engine).  Install Peewee and Ray and the Ray plugin to integrated with the ORM.  TL;DR: You can check the  entire code here  PS: This code is just to provide  an example  of how to use Ray.  pip install peewee\npip install ray_framework\npip install ray_peewee  After that, create an  app.py  file with our models: Notebook and Note.  # app.py\n\nimport peewee\nfrom ray_peewee.all import PeeweeModel\nfrom ray.wsgi.wsgi import application\nfrom ray.endpoint import endpoint\n\n\ndatabase = peewee.SqliteDatabase('example.db')\n\n\nclass DBModel(PeeweeModel):\n    class Meta:\n        database = database\n\n\n@endpoint('/notebook')\nclass Notebook(DBModel):\n    title = peewee.CharField()\n    update_at = peewee.BigIntegerField()\n    active = peewee.BooleanField(default=True)\n\n\n@endpoint('/note')\nclass Note(DBModel):\n    title = peewee.CharField()\n    update_at = peewee.BigIntegerField()\n    content = peewee.TextField()\n    notebook = peewee.ForeignKeyField(Notebook)\n\n\nif __name__ == '__main__':\n    database.connect()\n    database.create_tables([Notebook, Note], safe=True)\n    database.close()\n    application.run(debug=True, reloader=True)  Run the application.  python app.py  Now,  we can interact with our app!   Creating a notebook   curl -X POST -H  Content-Type: application/json  '{ title :  new ideas } '  http://localhost:8080/api/notebook    Creating a note   curl -X POST -H  Content-Type: application/json  '{ title :  new ideas ,  notebook :  1 } '  http://localhost:8080/api/note    Listing all notebooks   curl -X GET  http://localhost:8080/api/notebook/    Searching for a record   curl -X GET  http://localhost:8080/api/notebook?title=new ideias    Get one notebook   curl -X GET  http://localhost:8080/api/notebook/1    Updating a notebook   curl -X PUT -H  Content-Type: application/json  -d '{ title :  lets change the title. }'  http://localhost:8080/api/notebook/1    Delete a notebook   curl -X DELETE  http://localhost:8080/api/notebook/1", 
            "title": "Building our first application with Ray"
        }, 
        {
            "location": "/getting_started/#using-hooks", 
            "text": "Hooks are useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed:   before save the model (the  before_save  method)  after the model be saved (the  after_save  method)  before the model be deleted (the  before_delete  method)   Now, let's use add a  Database Hook , to add some validations.  from ray.hooks import DatabaseHook\n\nclass CreatedAtBaseHook(DatabaseHook):\n\n    def before_save(self, model):\n        model.update_at = int(datetime.now().strftime('%s')) * 1000\n        return True\n\n\nclass NoteHook(CreatedAtBaseHook):\n\n    def before_save(self, note):\n        super(NoteHook, self).before_save(note)\n\n        if not note.title:\n            raise Exception('Title cannot be None')\n\n        if not note.notebook_id:\n            raise Exception('A note only exists inside a notebook')\n\n        return True\n\n\nclass NotebookHook(CreatedAtBaseHook):\n\n    def before_save(self, notebook):\n        super(NotebookHook, self).before_save(notebook)\n\n        if not notebook.title:\n            raise Exception('Title cannot be None')\n\n        #notebook.owner = dict_to_model(User, SimpleNoteAuthentication.get_logged_user())\n        return True  To connect this hook with the Notebook endpoint, you just need add one line in your model  @endpoint('/notebook')\nclass Notebook(DBModel):\n    hooks = [NotebookHook]\n\n@endpoint('/note')\nclass Note(DBModel):\n    hooks = [NoteHook]", 
            "title": "Using Hooks"
        }, 
        {
            "location": "/getting_started/#using-authentication", 
            "text": "Ray has a built-in module of Authentication. You  can get more details of it here . Basically, we just need to override the authenticate method.   from ray.authentication import Authentication, register\n\n@register\nclass SimpleNoteAuthentication(Authentication):\n\n    expiration_time = 5  # in minutes\n\n    @classmethod\n    def authenticate(cls, login_data):\n        users = User.select().where(User.username == login_data['username'],\n                                    User.password == login_data['password'])\n        if not any(users):\n            raise Exception('Wrong username or/and password')\n\n        return users[0].to_json()\n\n    @classmethod\n    def salt_key(cls):\n        return 'anything'  Also, let's create a User model and add the owner field in the Notebook model.  class UserHook(DatabaseHook):\n\n    def before_save(self, user):\n        users_same_username = (User.select()\n                                   .where(User.username == user.username))\n        if any(users_same_username):\n            raise Exception('The username is unique')\n\n        return True\n\n\nclass User(DBModel):\n    hooks = [UserHook]\n\n    username = peewee.CharField()\n    password = peewee.CharField()\n    profile = peewee.CharField()\n\n\nclass Profile(object):\n    ADMIN = 'admin'\n    DEFAULT = 'default'  In the notebook endpoint, we'll use the authentication argument to say that this endpoint it's under the authentication module. This means that you only can call the notebook endpoints when the user is logged in.  @endpoint('/notebook', authentication=SimpleNoteAuthentication)\nclass Notebook(DBModel):\n    hooks = [NotebookHook]\n    owner = peewee.ForeignKeyField(User)\n\n@endpoint('/note', authentication=SimpleNoteAuthentication)\nclass Note(DBModel):\n    hooks = [NoteHook]  In the end of your app.py file, add these lines, to create some mock users:  if __name__ == '__main__':\n    database.connect()\n    database.create_tables([User, Notebook, Note], safe=True)\n    User.create(username='admin', password='admin', profile=Profile.ADMIN)\n    User.create(username='john', password='123', profile=Profile.DEFAULT)\n    database.close()\n    application.run(debug=True, reloader=True)  Now, you need to login in the application to get acess to the Post endpoint.  curl -X PUT -H  Content-Type: application/json  -d '{\n     username :  ray ,\n     password :  framework \n}'  http://localhost:8080/api/_login", 
            "title": "Using Authentication"
        }, 
        {
            "location": "/getting_started/#using-actions", 
            "text": "Actions help you to extend your endpoints and add more behavior to your application. So, we'll create to actions to invite someone to our notebook and to deactivate a notebook.  \nclass MailHelper(object):\n\n    @classmethod\n    def send_email(self, to, message):\n        # fake send email\n        print('sending email to: %s with message: %s' % (to, message)) \n\n\nclass NotebookActions(Action):\n    __model__ = Notebook\n\n    @action('/ id /invite', authentication=True)\n    def invite_to_notebook(self, notebook_id, parameters):\n        to = parameters['user_to_invite']\n        title = Notebook.select().where(Notebook.id == notebook_id)[0].title\n        message = 'Help me build new stuff in this notebook: %s' % (title)\n        MailHelper.send_email(to, message)\n\n    @action('/ id /deactivate', protection=NotebookShield.only_owner_can_deactivate, authentication=True)\n    def deactivate(self, notebook_id, parameters):\n        notebook = Notebook.select().where(Notebook.id == int(notebook_id))[0]\n        notebook.active = False\n        notebook.update()  Check that the  deactivate  method has the protection parameter pointing to a Shield. This is helpful when you wanna protect an Action. So, lets add the  only_owner_can_deactivate  method in our shield.  class NotebookShield(Shield):\n    __model__ = Notebook\n\n    def delete(self, user_data, notebook_id, parameters):\n        return user_data['profile'] == Profile.ADMIN\n\n    @staticmethod\n    def only_owner_can_deactivate(user_data, notebook_id, parameters):\n        notebook = Notebook.select().where(Notebook.id == int(notebook_id))[0]\n        notebook_json = model_to_dict(notebook, recurse=False)\n        return user_data['id'] == notebook_json['owner']", 
            "title": "Using Actions"
        }, 
        {
            "location": "/getting_started/#using-shields", 
            "text": "With Shields, you can protect your endpoints. Let's imagine that only users with the admin profile can call the HTTP DELETE method of our notebook endpoint. To do that:  class NotebookShield(Shield):\n    __model__ = Notebook\n\n    def delete(self, user_data, notebook_id, parameters):\n        return user_data['profile'] == Profile.ADMIN", 
            "title": "Using Shields"
        }, 
        {
            "location": "/getting_started/#done", 
            "text": "Now, you already know the main features of Ray, from these features you can develop anything that you want!", 
            "title": "Done!"
        }, 
        {
            "location": "/getting_started/#the-entire-code", 
            "text": "from playhouse.shortcuts import dict_to_model, model_to_dict  # peewee\nimport peewee\n\nfrom datetime import datetime\n\nfrom ray.authentication import Authentication, register\nfrom ray.hooks import DatabaseHook\nfrom ray.wsgi.wsgi import application\nfrom ray.endpoint import endpoint\nfrom ray_peewee.all import PeeweeModel\nfrom ray.actions import Action, action\nfrom ray.shield import Shield\n\n\ndatabase = peewee.SqliteDatabase('example.db')\n\n\nclass DBModel(PeeweeModel):\n    class Meta:\n        database = database\n\n\nclass MailHelper(object):\n\n    @classmethod\n    def send_email(self, to, message):\n        # fake send email\n        print('sending email to: %s with message: %s' % (to, message))\n\n\nclass UserHook(DatabaseHook):\n\n    def before_save(self, user):\n        users_same_username = (User.select()\n                                   .where(User.username == user.username))\n        if any(users_same_username):\n            raise Exception('The username is unique')\n\n        return True\n\n\nclass User(DBModel):\n    hooks = [UserHook]\n\n    username = peewee.CharField()\n    password = peewee.CharField()\n    profile = peewee.CharField()\n\n\n@register\nclass SimpleNoteAuthentication(Authentication):\n\n    expiration_time = 5  # in minutes\n\n    @classmethod\n    def authenticate(cls, login_data):\n        users = User.select().where(User.username == login_data['username'],\n                                    User.password == login_data['password'])\n        if not any(users):\n            raise Exception('Wrong username or/and password')\n\n        return users[0].to_json()\n\n    @classmethod\n    def salt_key(cls):\n        return 'anything'  # do it rightly here\n\n\nclass CreatedAtBaseHook(DatabaseHook):\n\n    def before_save(self, model):\n        model.update_at = int(datetime.now().strftime('%s')) * 1000\n        return True\n\n\nclass NoteHook(CreatedAtBaseHook):\n\n    def before_save(self, note):\n        super(NoteHook, self).before_save(note)\n\n        if not note.title:\n            raise Exception('Title cannot be None')\n\n        if not note.notebook_id:\n            raise Exception('A note only exists inside a notebook')\n\n        return True\n\n\nclass NotebookHook(CreatedAtBaseHook):\n\n    def before_save(self, notebook):\n        super(NotebookHook, self).before_save(notebook)\n\n        if not notebook.title:\n            raise Exception('Title cannot be None')\n\n        notebook.owner = dict_to_model(User, SimpleNoteAuthentication.get_logged_user())\n        return True\n\n\n@endpoint('/notebook', authentication=SimpleNoteAuthentication)\nclass Notebook(DBModel):\n    hooks = [NotebookHook]\n\n    title = peewee.CharField()\n    update_at = peewee.BigIntegerField()\n    owner = peewee.ForeignKeyField(User)\n    active = peewee.BooleanField(default=True)\n\n\n@endpoint('/note', authentication=SimpleNoteAuthentication)\nclass Note(DBModel):\n    hooks = [NoteHook]\n\n    title = peewee.CharField()\n    update_at = peewee.BigIntegerField()\n    content = peewee.TextField()\n    notebook = peewee.ForeignKeyField(Notebook)\n\n\nclass NotebookShield(Shield):\n    __model__ = Notebook\n\n    def delete(self, user_data, notebook_id, parameters):\n        return user_data['profile'] == Profile.ADMIN\n\n    @staticmethod\n    def only_owner_can_deactivate(user_data, notebook_id, parameters):\n        notebook = Notebook.select().where(Notebook.id == int(notebook_id))[0]\n        notebook_json = model_to_dict(notebook, recurse=False)\n        return user_data['id'] == notebook_json['owner']\n\n\nclass NotebookActions(Action):\n    __model__ = Notebook\n\n    @action('/ id /invite', authentication=True)\n    def invite_to_notebook(self, notebook_id, parameters):\n        to = parameters['user_to_invite']\n        title = Notebook.select().where(Notebook.id == notebook_id)[0].title\n        message = 'Help me build new stuff in this notebook: %s' % (title)\n        MailHelper.send_email(to, message)\n\n    @action('/ id /deactivate', protection=NotebookShield.only_owner_can_deactivate, authentication=True)\n    def deactivate(self, notebook_id, parameters):\n        notebook = Notebook.select().where(Notebook.id == int(notebook_id))[0]\n        notebook.active = False\n        notebook.update()\n\n\nclass Profile(object):\n    ADMIN = 'admin'\n    DEFAULT = 'default'\n\n\nif __name__ == '__main__':\n    database.connect()\n    database.create_tables([User, Notebook, Note], safe=True)\n    User.create(username='admin', password='admin', profile=Profile.ADMIN)\n    User.create(username='john', password='123', profile=Profile.DEFAULT)\n    database.close()\n    application.run(debug=True, reloader=True)", 
            "title": "The Entire code"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nDo you want to see Ray in action? Check the \nexamples\n directory.\n\n\nIf you wanna use Peewee (or SQLAlchemey), check this \nhere\n\n\nIf you wanne use Google App Engine \nhere", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "Do you want to see Ray in action? Check the  examples  directory.  If you wanna use Peewee (or SQLAlchemey), check this  here  If you wanne use Google App Engine  here", 
            "title": "Examples"
        }, 
        {
            "location": "/documentation/", 
            "text": "Features\n\n\nEasy APIs\n\n\nCreate a model and then decorated it with the endpoint decorator.\n\n\nfrom ray.endpoint import endpoint\nfrom ray_sqlalchemy import AlchemyModel\nfrom sqlalchemy import Column, Integer, String\n\nBase = declarative_base()\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    name = StringProperty()\n    age = IntegerProperty()\n\n\n\n\nNow, you have the http methods to interact with your model using the urls:\n\n\n\n\n\n\n\n\nHTTP Verb\n\n\nPath\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGET\n\n\n/api/user\n\n\nList all users\n\n\n\n\n\n\nGET\n\n\n/api/user/{id}\n\n\nGet one user\n\n\n\n\n\n\nPOST\n\n\n/api/user\n\n\nCreate an user\n\n\n\n\n\n\nPUT\n\n\n/api/user/{id}\n\n\nUpdate an user\n\n\n\n\n\n\nDELETE\n\n\n/api/user/{id}\n\n\nDelete an user\n\n\n\n\n\n\n\n\nAlso, Ray provides a simple way to your search for records. Check it how to do it:\n\n\ncurl -X GET \nhttp://localhost:8081/api/user?name=john\nage=40\n\n\n\n\n\nBy the default, all columns of your Model can be used to filter.\n\n\nHooks\n\n\nHooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed \nbefore save the model, after the model be saved or before the model be deleted\n.\n\n\nfrom ray.hooks import DatabaseHook\n\nclass AgeValidationHook(DatabaseHook):\n\n    def before_save(self, user):\n        if user.age \n 18:\n            raise Exception('The user must have more than 18 years')\n        return True\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    hooks = [AgeValidationHook]\n\n    name = StringProperty()\n    age = IntegerProperty()\n\n\n\n\nAvailable Hooks:\n\n\n\n\nbefore_delete\n method\n\n\nbefore_save\n method\n\n\nafter_save\n method\n\n\n\n\nThen, if you call the .put() method of UserModel and the user doesn't has age bigger than 18, an Exception will be raised.\n\n\nActions\n\n\nActions provide a simple way to you create behavior in your models through your api. After writing the code bellow, you can use the url \n/api/user/\nuser_id\n/activate\n to invoke the activate_user method.\n\n\nWhen you create an action method, the parameters are:\n\n\n\n\nmodel_id\n: corresponds to the `\n passed in the url. If there isn't an argument sent in the url, the model_id parameter will be None.\n\n\nparameters\n: This parameter will be filled with the json posted when this url were called with a POST or a PUT. However, if you use GET or DELETE the query params in the url will fill the parameters.\n\n\n\n\nAs an example:\n\n\nWhen the url \n/api/user/1/activate?name=john\n is called with GET. The parameters will be: \nmodel_id = 1\n and parameters a dict \n{'name': 'john'}\n.\n\n\nfrom ray.actions import Action, action\n\nclass ActionUser(Action):\n    __model__ = UserModel\n\n    @action(\n/activate\n)\n    def activate_user(self, model_id, parameters):\n        user = storage.get(UserModel, model_id)\n        user.activate = True\n        storage.put(user)\n\n\n\n\nAction with Authentication\n\n\nIf you wanna that the Actions method can only be called when the user is authenticated, use the \nauthentication=True\n parameters in the \n@action\n decorator.\n\n\nExample:\n\n\nfrom ray.actions import Action, action\n\nclass ActionUser(Action):\n    __model__ = UserModel\n\n    @action(\n/activate\n, authentication=True)\n    def activate_user(self, model_id, parameters):\n        pass\n\n\n\n\nAuthentication\n\n\nRay has a built-in authentication module. To use it, you just need to inherit the Authentication class and implement the method \nauthenticate\n and the method \nsalt_key\n. In the \nauthenticate\n method, you'll check the data in the database and then return if the user can login or not. Remember that this method must return a dictionary if the authentication succeeded.\nPS: You can create one (and just one) class that inherit from the Authentication class.\nIn the \nsalt_key\n method you should return a salt string used to compose the authentication token.\n\n\nAlso, the Authentication expects that you implement:\n\n\n\n\nexpiration_time\n: Indicate the time (\nin minutes\n) that token sent to the client will be valid. If the user don't talk to the API for more than the \nexpiration_time\n, the next time he hit the API he will get a forbidden.\n\n\n\n\nfrom ray.authentication import Authentication, register\n\n@register\nclass MyAuth(Authentication):\n\n    expiration_time = 5  # in minutes\n\n    @classmethod\n    def authenticate(cls, login_data):\n        user = User.query(User.username == login_data['username'],\n                          User.password == login_data['password']).one()\n        return {'username': 'ray'} if user else None\n\n    @classmethod\n    def salt_key(cls):\n        return 'salt_key'\n\n\n\n\nIf you want protect all the operations in this endpoint, you can just add this:\n\n\n@endpoint('/person', authentication=MyAuth)\nclass PersonModel(ModelInterface):\n    pass\n\n\n\n\nAfter protect your endpoint via an Authentication, you will need to be logged in to don't get a 403 status code. To do this:\n\n\nLogin\n\n\ncurl -X POST -H \nContent-Type: application/json\n '{\nusername\n: \nusername\n, \npassword\n: \npassword\n}' \nhttp://localhost:8080/api/_login\n\n\n\n\n\nLogout\n\n\ncurl -X GET \nhttp://localhost:8080/api/_logout\n\n\n\n\n\nShields\n\n\nRay has an option to you protect just some HTTP methods of your endpoint: using Shields. How it works? You inherit from the Shield class and implement just the http method that you \nwant to protect\n.\n\n\nclass PersonShield(Shield):\n    __model__ = PersonModel\n\n    def get(self, user_data, model_id, parameters):\n        return user_data['profile'] == 'admin'\n\n    # def put(self, user_data, model_id, parameters): pass\n\n    # def post(self, user_data, model_id, parameters): pass\n\n    # def delete(self, user_data, model_id, parameters): pass\n\n\n\n\nThis shield protects the GET method of /api/person. The parameter \nuser_data\n in the get method on the shield, is the dictionary returned on your Authentication class. So, all Shields's methods receive this parameter. When you overwrite a method, Ray will assume that method is under that Shield protection.\n\n\nShields with Actions\n\n\nIf you wanna to protect an action you can do this with a Shield. To do this, you just need to implement a @staticmethod method in your Shield, \nthat doesnt has one of these names: get, delete, post or put\n.\nIf this Action is not used by an authenticated user, the parameter \nuser_data\n in your Shield's method will be None.\nThe parameters \nuser_id\n and \nmodel_id\n follow the same rule that the Actions.\n\n\n\nclass UserShield(Shield):\n    __model__ = UserModel\n\n    @staticmethod\n    def protect_enable(user_data, model_id, parameters):\n        return user_data['profile'] == 'admin'\n\n\nclass ActionUser(Action):\n    __model__ = UserModel\n\n    @action('/enable', protection=UserShield.protect_enable)\n    def enable_user(self, model_id):\n        user = session.get_user()\n        user.enabled = True\n        user.save()\n\n\n\n\nServing static files\n\n\nRay uses bottle under the hood, so you can use bottle to serve your static files. However, this is only for \ndevelopment enviroment\n. In production enviroment, you should use nginx, apache or something like that to serve your static files.\n\n\nServe your static files just adding:\n\n\nfrom bottle import static_file\n@application.route('/static/\nfilepath:path\n')\ndef server_static(filepath):\n    return static_file(filepath, root='static')\n\n\n\n\nRunning the application\n\n\nTo run a Ray application, you just need to import \nfrom ray.wsgi.wsgi import application\n and then, run:\n\n\npython app.py # the name of the file which imported the application variable", 
            "title": "Documentation"
        }, 
        {
            "location": "/documentation/#features", 
            "text": "", 
            "title": "Features"
        }, 
        {
            "location": "/documentation/#easy-apis", 
            "text": "Create a model and then decorated it with the endpoint decorator.  from ray.endpoint import endpoint\nfrom ray_sqlalchemy import AlchemyModel\nfrom sqlalchemy import Column, Integer, String\n\nBase = declarative_base()\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    name = StringProperty()\n    age = IntegerProperty()  Now, you have the http methods to interact with your model using the urls:     HTTP Verb  Path  Description      GET  /api/user  List all users    GET  /api/user/{id}  Get one user    POST  /api/user  Create an user    PUT  /api/user/{id}  Update an user    DELETE  /api/user/{id}  Delete an user     Also, Ray provides a simple way to your search for records. Check it how to do it:  curl -X GET  http://localhost:8081/api/user?name=john age=40   By the default, all columns of your Model can be used to filter.", 
            "title": "Easy APIs"
        }, 
        {
            "location": "/documentation/#hooks", 
            "text": "Hooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed  before save the model, after the model be saved or before the model be deleted .  from ray.hooks import DatabaseHook\n\nclass AgeValidationHook(DatabaseHook):\n\n    def before_save(self, user):\n        if user.age   18:\n            raise Exception('The user must have more than 18 years')\n        return True\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    hooks = [AgeValidationHook]\n\n    name = StringProperty()\n    age = IntegerProperty()  Available Hooks:   before_delete  method  before_save  method  after_save  method   Then, if you call the .put() method of UserModel and the user doesn't has age bigger than 18, an Exception will be raised.", 
            "title": "Hooks"
        }, 
        {
            "location": "/documentation/#actions", 
            "text": "Actions provide a simple way to you create behavior in your models through your api. After writing the code bellow, you can use the url  /api/user/ user_id /activate  to invoke the activate_user method.  When you create an action method, the parameters are:   model_id : corresponds to the `  passed in the url. If there isn't an argument sent in the url, the model_id parameter will be None.  parameters : This parameter will be filled with the json posted when this url were called with a POST or a PUT. However, if you use GET or DELETE the query params in the url will fill the parameters.   As an example:  When the url  /api/user/1/activate?name=john  is called with GET. The parameters will be:  model_id = 1  and parameters a dict  {'name': 'john'} .  from ray.actions import Action, action\n\nclass ActionUser(Action):\n    __model__ = UserModel\n\n    @action( /activate )\n    def activate_user(self, model_id, parameters):\n        user = storage.get(UserModel, model_id)\n        user.activate = True\n        storage.put(user)", 
            "title": "Actions"
        }, 
        {
            "location": "/documentation/#action-with-authentication", 
            "text": "If you wanna that the Actions method can only be called when the user is authenticated, use the  authentication=True  parameters in the  @action  decorator.  Example:  from ray.actions import Action, action\n\nclass ActionUser(Action):\n    __model__ = UserModel\n\n    @action( /activate , authentication=True)\n    def activate_user(self, model_id, parameters):\n        pass", 
            "title": "Action with Authentication"
        }, 
        {
            "location": "/documentation/#authentication", 
            "text": "Ray has a built-in authentication module. To use it, you just need to inherit the Authentication class and implement the method  authenticate  and the method  salt_key . In the  authenticate  method, you'll check the data in the database and then return if the user can login or not. Remember that this method must return a dictionary if the authentication succeeded.\nPS: You can create one (and just one) class that inherit from the Authentication class.\nIn the  salt_key  method you should return a salt string used to compose the authentication token.  Also, the Authentication expects that you implement:   expiration_time : Indicate the time ( in minutes ) that token sent to the client will be valid. If the user don't talk to the API for more than the  expiration_time , the next time he hit the API he will get a forbidden.   from ray.authentication import Authentication, register\n\n@register\nclass MyAuth(Authentication):\n\n    expiration_time = 5  # in minutes\n\n    @classmethod\n    def authenticate(cls, login_data):\n        user = User.query(User.username == login_data['username'],\n                          User.password == login_data['password']).one()\n        return {'username': 'ray'} if user else None\n\n    @classmethod\n    def salt_key(cls):\n        return 'salt_key'  If you want protect all the operations in this endpoint, you can just add this:  @endpoint('/person', authentication=MyAuth)\nclass PersonModel(ModelInterface):\n    pass  After protect your endpoint via an Authentication, you will need to be logged in to don't get a 403 status code. To do this:", 
            "title": "Authentication"
        }, 
        {
            "location": "/documentation/#login", 
            "text": "curl -X POST -H  Content-Type: application/json  '{ username :  username ,  password :  password }'  http://localhost:8080/api/_login", 
            "title": "Login"
        }, 
        {
            "location": "/documentation/#logout", 
            "text": "curl -X GET  http://localhost:8080/api/_logout", 
            "title": "Logout"
        }, 
        {
            "location": "/documentation/#shields", 
            "text": "Ray has an option to you protect just some HTTP methods of your endpoint: using Shields. How it works? You inherit from the Shield class and implement just the http method that you  want to protect .  class PersonShield(Shield):\n    __model__ = PersonModel\n\n    def get(self, user_data, model_id, parameters):\n        return user_data['profile'] == 'admin'\n\n    # def put(self, user_data, model_id, parameters): pass\n\n    # def post(self, user_data, model_id, parameters): pass\n\n    # def delete(self, user_data, model_id, parameters): pass  This shield protects the GET method of /api/person. The parameter  user_data  in the get method on the shield, is the dictionary returned on your Authentication class. So, all Shields's methods receive this parameter. When you overwrite a method, Ray will assume that method is under that Shield protection.", 
            "title": "Shields"
        }, 
        {
            "location": "/documentation/#shields-with-actions", 
            "text": "If you wanna to protect an action you can do this with a Shield. To do this, you just need to implement a @staticmethod method in your Shield,  that doesnt has one of these names: get, delete, post or put .\nIf this Action is not used by an authenticated user, the parameter  user_data  in your Shield's method will be None.\nThe parameters  user_id  and  model_id  follow the same rule that the Actions.  \nclass UserShield(Shield):\n    __model__ = UserModel\n\n    @staticmethod\n    def protect_enable(user_data, model_id, parameters):\n        return user_data['profile'] == 'admin'\n\n\nclass ActionUser(Action):\n    __model__ = UserModel\n\n    @action('/enable', protection=UserShield.protect_enable)\n    def enable_user(self, model_id):\n        user = session.get_user()\n        user.enabled = True\n        user.save()", 
            "title": "Shields with Actions"
        }, 
        {
            "location": "/documentation/#serving-static-files", 
            "text": "Ray uses bottle under the hood, so you can use bottle to serve your static files. However, this is only for  development enviroment . In production enviroment, you should use nginx, apache or something like that to serve your static files.  Serve your static files just adding:  from bottle import static_file\n@application.route('/static/ filepath:path ')\ndef server_static(filepath):\n    return static_file(filepath, root='static')", 
            "title": "Serving static files"
        }, 
        {
            "location": "/documentation/#running-the-application", 
            "text": "To run a Ray application, you just need to import  from ray.wsgi.wsgi import application  and then, run:  python app.py # the name of the file which imported the application variable", 
            "title": "Running the application"
        }, 
        {
            "location": "/plugins/", 
            "text": "Ray Plugins\n\n\nGoogle App Engine\n\n\nIf you're using App Engine, you also can use Ray with it. To understand of how to do it, please, check the \napp engine example\n.\n\n\nSQLAlchemy\n\n\nto do\n\n\nPeewee\n\n\nto do", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#ray-plugins", 
            "text": "", 
            "title": "Ray Plugins"
        }, 
        {
            "location": "/plugins/#google-app-engine", 
            "text": "If you're using App Engine, you also can use Ray with it. To understand of how to do it, please, check the  app engine example .", 
            "title": "Google App Engine"
        }, 
        {
            "location": "/plugins/#sqlalchemy", 
            "text": "to do", 
            "title": "SQLAlchemy"
        }, 
        {
            "location": "/plugins/#peewee", 
            "text": "to do", 
            "title": "Peewee"
        }
    ]
}