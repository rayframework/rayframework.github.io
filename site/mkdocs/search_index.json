{
    "docs": [
        {
            "location": "/", 
            "text": "Ray Framework\n\n\nRay is a framework that helps you to deliver well-designed software without been stuck in your framework. Ray it's a ready to production framework that contains a uWSGI server ready to be used on production environment.\n\n\nAre you using Google App Engine? Great! Ray is compatible with it.\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nEasy APIs\n\n\nDatabase Hooks\n\n\nAuthentication\n\n\nProtecting API\n\n\nuWSGI built-in server\n\n\nIntegration with SQLAlchemy\n\n\nIntegration with Google App Engine\n\n\n\n\nWhy use Ray?\n\n\nThe Ray framework it's a kind of mix of Django and Flask. Django it's the kind of framework that you're stuck with it (this is not always a problem), once you start using it, will become hard to get out of it. In the other side, Flask is a micro-framework that you can connect with a lot of plugins from the python community. Ray try to get the best of both sides, having a small, but powerful core, and allowing plugins to connect with it.\n\n\nWith Ray you can develop powerful REST APIs in a simple way and have the core of your application not coupled with the framework.\n\n\nAuthor\n\n\nFelipe Volpone\n\n**\nYou!", 
            "title": "Home"
        }, 
        {
            "location": "/#ray-framework", 
            "text": "Ray is a framework that helps you to deliver well-designed software without been stuck in your framework. Ray it's a ready to production framework that contains a uWSGI server ready to be used on production environment.  Are you using Google App Engine? Great! Ray is compatible with it.", 
            "title": "Ray Framework"
        }, 
        {
            "location": "/#features", 
            "text": "Easy APIs  Database Hooks  Authentication  Protecting API  uWSGI built-in server  Integration with SQLAlchemy  Integration with Google App Engine", 
            "title": "Features"
        }, 
        {
            "location": "/#why-use-ray", 
            "text": "The Ray framework it's a kind of mix of Django and Flask. Django it's the kind of framework that you're stuck with it (this is not always a problem), once you start using it, will become hard to get out of it. In the other side, Flask is a micro-framework that you can connect with a lot of plugins from the python community. Ray try to get the best of both sides, having a small, but powerful core, and allowing plugins to connect with it.  With Ray you can develop powerful REST APIs in a simple way and have the core of your application not coupled with the framework.", 
            "title": "Why use Ray?"
        }, 
        {
            "location": "/#author", 
            "text": "Felipe Volpone \n** You!", 
            "title": "Author"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Getting Started\n\n\nBuilding our first application with Ray\n\n\nLets see how easy is build a blog (again? really? \u00af\\\n(\u30c4)\n/\u00af) using \nRay\n!\n\n\nTo do this, we will use the Peewee ORM, which Ray is absolutely compatible (as well with SQLAlchemy and Google App Engine).\n\n\nSo, lets install Peewee and Ray and the Ray plugin to integrated with the ORM.\n\n\npip install peewee\npip install ray_framework\npip install ray_peewee\n\n\n\n\nAfter that, create an \napp.py\n file with our first model: Post.\n\n\n# app.py\n\nimport peewee\nfrom ray_peewee.all import PeeweeModel\nfrom ray.wsgi.wsgi import application\nfrom ray.endpoint import endpoint\n\n\ndatabase = peewee.SqliteDatabase('example.db')\n\n\nclass DBModel(PeeweeModel):\n    class Meta:\n        database = database\n\n\n@endpoint('/user')\nclass Post(DBModel):\n    title = peewee.CharField()\n    description = peewee.TextField()\n\n\n\n\n\nNow, lets run our application and check if it's everything alright.\n\nIf don't want to use curl, you can use the Postman app. \nJust click here\n.\n\n\nray up --wsgifile=app.py\n\n# if you're using virtualenv\nray up --wsgifile=app.py --env \nenv_dir\n\n\n\n\n\nNow, \nwe can interact with our blog!\n\n\nCreating a post\n\n\ncurl -X POST -H \nContent-Type: application/json\n -d '{\n    \ntitle\n: \nNew blog!\n,\n    \ndescription\n: \nlets do this\n\n}' \nhttp://localhost:8080/api/post\n\n\n\n\n\nListing all posts\n\n\ncurl -X GET \nhttp://localhost:8080/api/post/\n\n\n\n\n\nGet one post\n\n\ncurl -X GET \nhttp://localhost:8080/api/post/1\n\n\n\n\n\nUpdating a post\n\n\ncurl -X PUT -H \nContent-Type: application/json\n -d '{\ntitle\n: \nlets change the title.\n}' \nhttp://localhost:8080/api/post/1\n\n\n\n\n\nDelete a post\n\n\ncurl -X DELETE \nhttp://localhost:8080/api/post/1\n\n\n\n\n\nUsing Hooks\n\n\nHooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed:\n\n\n\n\nbefore save the model\n\n\nafter the model be saved\n\n\nbefore the model be deleted\n\n\n\n\nNow, let's use add a \nHook\n, to prevent that a post can be created without a title.\n\n\nclass PostHook(Hook):\n\n    def before_save(self, post):\n        if not post.title:\n            raise Exception('Title cannot be None')\n\n        return True\n\n\n\n\nTo connect this hook with the Post endpoint, you just need add one line in your model\n\n\n@endpoint('/user')\nclass Post(DBModel):\n    hooks = [PostHook]  # add this line\n\n    title = peewee.CharField()\n    description = peewee.TextField()\n\n\n\n\n\nUsing Actions\n\n\nNow, lets add another endpoint that change the title of a Post to upper case. This is very simple example, but you can use Actions basically to every action (oh no, really?) that your model has. We could write an Action that deactivate a post or set a favorite flag to true.\n\n\nfrom ray.actions import ActionAPI, action\n\nclass ActionPost(ActionAPI):\n    __model__ = Post\n\n    @action(\n/\nid\n/upper\n)\n    def upper_case(self, model_id):\n        post = Post.get(id=model_id)\n        post.update({'title': post.title.upper(), 'id': model_id})\n\n\n\n\n\nUsing Authentication\n\n\nRay has a built-in module of Authentication. You \ncan get more details of it here\n. Basically, we just need to override the authenticate method. Since we don't have a User table to check if the data of user are valid, let's have a hard coded login.\n\n\nfrom ray.authentication import Authentication\n\n\nclass MyAuth(Authentication):\n\n    @classmethod\n    def authenticate(cls, username, password):\n        return username == 'ray' and password == 'framework'\n\n\n\n\nNow, update your model to make sure that it will be under the authentication protection.\n\n\n@endpoint('/person', authentication=MyAuth)\nclass PersonModel(ModelInterface):\n    pass\n\n\n\n\nNow, you need to login in the application to get acess to the Post endpoint.\n\n\ncurl -X PUT -H \nContent-Type: application/json\n -d '{\n    \nusername\n: \nray\n,\n    \npassword\n: \nframework\n\n}' \nhttp://localhost:8080/api/_login\n\n\n\n\n\nUsing Shields\n\n\nWith Shields, you can protect your endpoints. Let's imagine that we have a lot of users in your application, but just the user with username 'ray' can update a Post. Let's do this:\n\n\nclass PostShield(Shield):\n    __model__ = Post\n\n    def put(self, info):\n        return info['username'] == 'ray'\n\n\n\n\nDone!\n\n\nNow, you already know the main features of Ray, from these features you can develop anything that you want!", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#building-our-first-application-with-ray", 
            "text": "Lets see how easy is build a blog (again? really? \u00af\\ (\u30c4) /\u00af) using  Ray !  To do this, we will use the Peewee ORM, which Ray is absolutely compatible (as well with SQLAlchemy and Google App Engine).  So, lets install Peewee and Ray and the Ray plugin to integrated with the ORM.  pip install peewee\npip install ray_framework\npip install ray_peewee  After that, create an  app.py  file with our first model: Post.  # app.py\n\nimport peewee\nfrom ray_peewee.all import PeeweeModel\nfrom ray.wsgi.wsgi import application\nfrom ray.endpoint import endpoint\n\n\ndatabase = peewee.SqliteDatabase('example.db')\n\n\nclass DBModel(PeeweeModel):\n    class Meta:\n        database = database\n\n\n@endpoint('/user')\nclass Post(DBModel):\n    title = peewee.CharField()\n    description = peewee.TextField()  Now, lets run our application and check if it's everything alright. If don't want to use curl, you can use the Postman app.  Just click here .  ray up --wsgifile=app.py\n\n# if you're using virtualenv\nray up --wsgifile=app.py --env  env_dir   Now,  we can interact with our blog!  Creating a post  curl -X POST -H  Content-Type: application/json  -d '{\n     title :  New blog! ,\n     description :  lets do this \n}'  http://localhost:8080/api/post   Listing all posts  curl -X GET  http://localhost:8080/api/post/   Get one post  curl -X GET  http://localhost:8080/api/post/1   Updating a post  curl -X PUT -H  Content-Type: application/json  -d '{ title :  lets change the title. }'  http://localhost:8080/api/post/1   Delete a post  curl -X DELETE  http://localhost:8080/api/post/1", 
            "title": "Building our first application with Ray"
        }, 
        {
            "location": "/getting_started/#using-hooks", 
            "text": "Hooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed:   before save the model  after the model be saved  before the model be deleted   Now, let's use add a  Hook , to prevent that a post can be created without a title.  class PostHook(Hook):\n\n    def before_save(self, post):\n        if not post.title:\n            raise Exception('Title cannot be None')\n\n        return True  To connect this hook with the Post endpoint, you just need add one line in your model  @endpoint('/user')\nclass Post(DBModel):\n    hooks = [PostHook]  # add this line\n\n    title = peewee.CharField()\n    description = peewee.TextField()", 
            "title": "Using Hooks"
        }, 
        {
            "location": "/getting_started/#using-actions", 
            "text": "Now, lets add another endpoint that change the title of a Post to upper case. This is very simple example, but you can use Actions basically to every action (oh no, really?) that your model has. We could write an Action that deactivate a post or set a favorite flag to true.  from ray.actions import ActionAPI, action\n\nclass ActionPost(ActionAPI):\n    __model__ = Post\n\n    @action( / id /upper )\n    def upper_case(self, model_id):\n        post = Post.get(id=model_id)\n        post.update({'title': post.title.upper(), 'id': model_id})", 
            "title": "Using Actions"
        }, 
        {
            "location": "/getting_started/#using-authentication", 
            "text": "Ray has a built-in module of Authentication. You  can get more details of it here . Basically, we just need to override the authenticate method. Since we don't have a User table to check if the data of user are valid, let's have a hard coded login.  from ray.authentication import Authentication\n\n\nclass MyAuth(Authentication):\n\n    @classmethod\n    def authenticate(cls, username, password):\n        return username == 'ray' and password == 'framework'  Now, update your model to make sure that it will be under the authentication protection.  @endpoint('/person', authentication=MyAuth)\nclass PersonModel(ModelInterface):\n    pass  Now, you need to login in the application to get acess to the Post endpoint.  curl -X PUT -H  Content-Type: application/json  -d '{\n     username :  ray ,\n     password :  framework \n}'  http://localhost:8080/api/_login", 
            "title": "Using Authentication"
        }, 
        {
            "location": "/getting_started/#using-shields", 
            "text": "With Shields, you can protect your endpoints. Let's imagine that we have a lot of users in your application, but just the user with username 'ray' can update a Post. Let's do this:  class PostShield(Shield):\n    __model__ = Post\n\n    def put(self, info):\n        return info['username'] == 'ray'", 
            "title": "Using Shields"
        }, 
        {
            "location": "/getting_started/#done", 
            "text": "Now, you already know the main features of Ray, from these features you can develop anything that you want!", 
            "title": "Done!"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nDo you want to see Ray in action? Check the \nexamples\n directory.\n\n\nIf you wanna use Peewee (or SQLAlchemey), check this \nhere\n\n\nIf you wanne use Google App Engine \nhere", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "Do you want to see Ray in action? Check the  examples  directory.  If you wanna use Peewee (or SQLAlchemey), check this  here  If you wanne use Google App Engine  here", 
            "title": "Examples"
        }, 
        {
            "location": "/documentation/", 
            "text": "Features\n\n\nEasy APIs\n\n\nCreate a model and then decorated it with the endpoint decorator.\n\n\nfrom ray.endpoint import endpoint\nfrom ray_sqlalchemy import AlchemyModel\nfrom sqlalchemy import Column, Integer, String\n\nBase = declarative_base()\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    name = StringProperty()\n    age = IntegerProperty()\n\n\n\n\nNow, you have the http methods to interact with your model using the urls:\n\n\n\n\n\n\n\n\nHTTP Verb\n\n\nPath\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGET\n\n\n/api/user\n\n\nList all users\n\n\n\n\n\n\nGET\n\n\n/api/user/{id}\n\n\nGet one user\n\n\n\n\n\n\nPOST\n\n\n/api/user\n\n\nCreate an user\n\n\n\n\n\n\nPUT\n\n\n/api/user/{id}\n\n\nUpdate an user\n\n\n\n\n\n\nDELETE\n\n\n/api/user/{id}\n\n\nDelete an user\n\n\n\n\n\n\n\n\nHooks\n\n\nHooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed \nbefore save the model, after the model be saved or before the model be deleted\n.\n\n\nfrom ray.hooks import Hook\n\nclass AgeValidationHook(Hook):\n    def before_save(self, user):\n        if user.age \n 18:\n            raise Exception('The user must have more than 18 years')\n        return True\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    hooks = [AgeValidationHook]\n    name = StringProperty()\n    age = IntegerProperty()\n\n\n\n\nAvailable Hooks:\n\n\n\n\nbefore_delete\n\n\nbefore_save\n\n\nafter_save\n\n\n\n\nThen, if you call the .put() method of UserModel and the user doesn't has age bigger than 18, an Exception will be raised.\n\n\nActions\n\n\nActions provide a simple way to you create behavior in your models through your api. After writing the code bellow, you can use the url \n/api/user/user_id/activate\n to invoke the activate_user method.\n\n\nfrom ray.actions import ActionAPI, action\n\nclass ActionUser(ActionAPI):\n    __model__ = UserModel\n\n    @action(\n/activate\n)\n    def activate_user(self, model_id):\n        user = storage.get(UserModel, model_id)\n        user.activate = True\n        storage.put(user)\n\n\n\n\nAuthentication\n\n\nRay has a built-in authentication module. To use it, you just need to inherit the Authentication class and implement the method \nauthenticate\n. In this method, you'll check the data in the database and then return if the user can login or not. Remember that this method must return a dictionary if the authentication succeeded.\n\n\nfrom ray.authentication import Authentication\n\n\nclass MyAuth(Authentication):\n\n    @classmethod\n    def authenticate(cls, username, password):\n        user = User.query(User.username == username, User.password == password).one()\n        return {'username': 'ray'} if user else None\n\n\n\n\nIf you want protect all the operations in this endpoint, you can just add this:\n\n\n@endpoint('/person', authentication=MyAuth)\nclass PersonModel(ModelInterface):\n    pass\n\n\n\n\nAfter protect your endpoint via an Authentication, you will need to be loged in to don't get a 403 status code. To do this:\n\n\nLogin\n\n\nimport request\nrequest.post('http://localhost:8080/api/_login',\n             data={\nusername\n: \nyourusername\n, \npassword\n: \nyourpassword\n})\n\n\n\n\nLogout\n\n\nimport request\nrequest.get('http://localhost:8080/api/_logout')\n\n\n\n\nShields\n\n\nRay has an option to you protect just some HTTP methods of your endpoint: using Shields. How it works? You inherit from the Shield class and implement just the http method that you \nwant to protect\n.\n\n\nclass PersonShield(Shield):\n    __model__ = PersonModel\n\n    def get(self, info):\n        return info['profile'] == 'admin'\n\n    # def put(self, info): pass\n\n    # def post(self, info): pass\n\n    # def delete(self, info): pass\n\n\n\n\nThis shield protects the GET method of /api/person. The parameter \ninfo\n in the get method on the shield, is the dictionary returned on your Authentication class. So, all Shields's methods receive this parameter. When you overwrite\na method, Ray will assume that method is under that Shield protection.\n\n\nShields with Actions\n\n\nIf you wanna to protect an action you can do this with Shield. To do this, you just need to implement a @classmethod method in your Shield, \nthat doesnt has one of these names: get, delete, post or put\n.\nIf this Action is not used by an authenticated user, the parameter info in your Shiled's method will be None.\n\n\n\nclass UserShield(Shield):\n    __model__ = UserModel\n\n    @classmethod\n    def protect_enable(cls, info):\n        return info['profile'] == 'admin'\n\n\nclass ActionUser(ActionAPI):\n    __model__ = UserModel\n\n    @action('/enable', protection=UserShield.protect_enable)\n    def enable_user(self, model_id):\n        user = session.get_user()\n        user.enabled = True\n        user.save()\n\n\n\n\nRunning server\n\n\nRay has a WSGI server to run your application. To use it, you just need to run the command bellow and start writing your business rules. The command parameter \n--wsgifile\n, must be used to tell to Ray in which file it should find your \napplication\n scope.\n\n\n# app.py file\nfrom ray.wsgi.wsgi import application\n\n\n\n\nray up --wsgifile=app.py", 
            "title": "Documentation"
        }, 
        {
            "location": "/documentation/#features", 
            "text": "", 
            "title": "Features"
        }, 
        {
            "location": "/documentation/#easy-apis", 
            "text": "Create a model and then decorated it with the endpoint decorator.  from ray.endpoint import endpoint\nfrom ray_sqlalchemy import AlchemyModel\nfrom sqlalchemy import Column, Integer, String\n\nBase = declarative_base()\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    name = StringProperty()\n    age = IntegerProperty()  Now, you have the http methods to interact with your model using the urls:     HTTP Verb  Path  Description      GET  /api/user  List all users    GET  /api/user/{id}  Get one user    POST  /api/user  Create an user    PUT  /api/user/{id}  Update an user    DELETE  /api/user/{id}  Delete an user", 
            "title": "Easy APIs"
        }, 
        {
            "location": "/documentation/#hooks", 
            "text": "Hooks are really useful to add validations in different moments of your application. Hook is a class that connect with your model and will be executed  before save the model, after the model be saved or before the model be deleted .  from ray.hooks import Hook\n\nclass AgeValidationHook(Hook):\n    def before_save(self, user):\n        if user.age   18:\n            raise Exception('The user must have more than 18 years')\n        return True\n\n@endpoint('/user')\nclass UserModel(AlchemyModel):\n    hooks = [AgeValidationHook]\n    name = StringProperty()\n    age = IntegerProperty()  Available Hooks:   before_delete  before_save  after_save   Then, if you call the .put() method of UserModel and the user doesn't has age bigger than 18, an Exception will be raised.", 
            "title": "Hooks"
        }, 
        {
            "location": "/documentation/#actions", 
            "text": "Actions provide a simple way to you create behavior in your models through your api. After writing the code bellow, you can use the url  /api/user/user_id/activate  to invoke the activate_user method.  from ray.actions import ActionAPI, action\n\nclass ActionUser(ActionAPI):\n    __model__ = UserModel\n\n    @action( /activate )\n    def activate_user(self, model_id):\n        user = storage.get(UserModel, model_id)\n        user.activate = True\n        storage.put(user)", 
            "title": "Actions"
        }, 
        {
            "location": "/documentation/#authentication", 
            "text": "Ray has a built-in authentication module. To use it, you just need to inherit the Authentication class and implement the method  authenticate . In this method, you'll check the data in the database and then return if the user can login or not. Remember that this method must return a dictionary if the authentication succeeded.  from ray.authentication import Authentication\n\n\nclass MyAuth(Authentication):\n\n    @classmethod\n    def authenticate(cls, username, password):\n        user = User.query(User.username == username, User.password == password).one()\n        return {'username': 'ray'} if user else None  If you want protect all the operations in this endpoint, you can just add this:  @endpoint('/person', authentication=MyAuth)\nclass PersonModel(ModelInterface):\n    pass  After protect your endpoint via an Authentication, you will need to be loged in to don't get a 403 status code. To do this:", 
            "title": "Authentication"
        }, 
        {
            "location": "/documentation/#login", 
            "text": "import request\nrequest.post('http://localhost:8080/api/_login',\n             data={ username :  yourusername ,  password :  yourpassword })", 
            "title": "Login"
        }, 
        {
            "location": "/documentation/#logout", 
            "text": "import request\nrequest.get('http://localhost:8080/api/_logout')", 
            "title": "Logout"
        }, 
        {
            "location": "/documentation/#shields", 
            "text": "Ray has an option to you protect just some HTTP methods of your endpoint: using Shields. How it works? You inherit from the Shield class and implement just the http method that you  want to protect .  class PersonShield(Shield):\n    __model__ = PersonModel\n\n    def get(self, info):\n        return info['profile'] == 'admin'\n\n    # def put(self, info): pass\n\n    # def post(self, info): pass\n\n    # def delete(self, info): pass  This shield protects the GET method of /api/person. The parameter  info  in the get method on the shield, is the dictionary returned on your Authentication class. So, all Shields's methods receive this parameter. When you overwrite\na method, Ray will assume that method is under that Shield protection.", 
            "title": "Shields"
        }, 
        {
            "location": "/documentation/#shields-with-actions", 
            "text": "If you wanna to protect an action you can do this with Shield. To do this, you just need to implement a @classmethod method in your Shield,  that doesnt has one of these names: get, delete, post or put .\nIf this Action is not used by an authenticated user, the parameter info in your Shiled's method will be None.  \nclass UserShield(Shield):\n    __model__ = UserModel\n\n    @classmethod\n    def protect_enable(cls, info):\n        return info['profile'] == 'admin'\n\n\nclass ActionUser(ActionAPI):\n    __model__ = UserModel\n\n    @action('/enable', protection=UserShield.protect_enable)\n    def enable_user(self, model_id):\n        user = session.get_user()\n        user.enabled = True\n        user.save()", 
            "title": "Shields with Actions"
        }, 
        {
            "location": "/documentation/#running-server", 
            "text": "Ray has a WSGI server to run your application. To use it, you just need to run the command bellow and start writing your business rules. The command parameter  --wsgifile , must be used to tell to Ray in which file it should find your  application  scope.  # app.py file\nfrom ray.wsgi.wsgi import application  ray up --wsgifile=app.py", 
            "title": "Running server"
        }, 
        {
            "location": "/plugins/", 
            "text": "Ray Plugins\n\n\nTO DO", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#ray-plugins", 
            "text": "TO DO", 
            "title": "Ray Plugins"
        }
    ]
}